syntax = "proto3";

import "pond.proto";

import "google/api/annotations.proto";

package netbeam;

option go_package = "github.com/esnet/proto/go/netbeam";

message Empty {
}

// The namespace, which is made up of the organization and the collection e.g. { organization: "esnet", collection: "prod"}
message Namespace {
    // The organization this request is associated with e.g. "esnet"
    string organization = 1;

    // The collection within the organization's data the request is for. e.g. "prod"
    string collection = 2;
}

// The full resource path e.g. ["devices", "chic-cr5", "interfaces", "1/1/1"]
message Resource {
    repeated string path = 1;
}

message Organization {
    // The database ID of the organization
    int32 id = 1;

    // The short name of the organization
    string name = 2;

    // A longer more descriptive name for the organization
    string description = 3;
}

message OrganizationList {
    // The list of organizations
    repeated Organization organizations = 1;
}

message Collection {
    // The database ID of the Collection
    int32 id = 1;

    // The namespace of anything within this Collection, contains both the Organization name
    // and the Collection name e.g. {organization: "esnet", collection: "prod"}
    Namespace namespace = 2;

    // A longer more human readable name or description for the Collection
    string description = 3;
}

message CollectionList {
    // A list of Collections
    repeated Collection collections = 1;
}

message ResourceGroup {
    // The database ID of the resource group
    int32 id =1;

    // The short name of the resource group
    string name = 2;

    // The namespace of anything within this Collection, contains both the Organization name
    // and the Collection name e.g. {organization: "esnet", collection: "prod"}
    Namespace namespace = 3;
}

message ResourceGroupList {
    // A list of ResourceGroups
    repeated ResourceGroup resourceGroups = 1;
}

message Source {
    // The database ID of the Source
    int32 id = 1;

    // The namespace that contains the Source e.g. {organization: "esnet", collection: "prod"}
    Namespace namespace = 2;

    // The index of the Source, which is how the Source is referred to within ingest Events
    int32 index = 3;

     // Priority, which determines which Events will be used if the same Event comes from multiple sources
    int32 priority = 4;

    // Description of the Source and what it represents
    string description = 5;
}

message SourceList {
    // The list of Sources
    repeated Source sources = 1;
}

// An ingest rule that describes at a high level how some particular metric will be processed.
// This consists of three parts: A matcher (based on the namespace of the event and the scope
// that matches the resource), a Type (which corresponds to different netbeam handling of the event),
// and finally parameters which further control the way that metric is processed (alignment of
// the data, naming and units).
message Rule {
    // The ID of the Metric
    int32 id = 1;

    // The namespace to register the rule within
    Namespace namespace = 2;

    enum Type {
        BYTES = 0;
        COUNTER = 1;
        GAUGE = 2;
        STRING = 3;
    }

    // The type of the metric: bytes, counter, gauge or string
    Type type = 3;

    // The scope wildcard which determines which Resources the Metric will apply to
    string scope = 4;

    // The base name of the metric e.g. "traffic"
    string name = 5;

    // The suffic of the metric e.g. "in" or "out"
    string suffix = 6;

    // The suffix for the output tiles if those are generated by the Rule type. For example when
    // writing SAPs, both in_inProfile and in_outProfile are written to the tag suffix "in"
    string tag_suffix = 7;

    // The alignment of the data to periodic boundaries
    string align = 8;

    // The  units of the output data if applicable. Applies to gauges and counters. Counters with units of
    // bytes is assumed to output bits per second rates. This is a special case. String types are unitless.
    // A gauge of say kb of memory will output kb as its units. A counter of units "errors" will output a
    // rate of errors as "errors/sec".
    string units = 9;

}

message RuleList {
    // The list of rules
    repeated Rule rules = 1;
}

//
// Datagraphs
//

message Matchers {
    // The namespace the list of Matchers applies to e.g. esnet/prod
    Namespace namespace = 1;

    // A list of matchers within that namespace
    repeated Matcher matchers = 2;
}

message Matcher {

    // The name of the matcher
    string name = 1;

    // The matcher's wildcards against the incoming resource. If any of the wildcards
    // matches against the resources the rule will be active.
    repeated string scope = 2;

    // A human readable description as to what this matcher represents
    string description = 3;

    // Units of the metrics that this matcher applies to
    string units = 4;

    // Alignment of this data, for example "30s" would align this data to every 30 seconds (4:30, 5:00, 5:30 ...)
    string align = 5;

    // A list of processors to run as a result of this match on the incoming metric event. A processor will
    // transform this Event into another Event (with a different metric name) that may match other Matchers.
    repeated Processor processors = 6;

    // A list of Outputs which will write or otherwise emit the data, for example to a specific table.
    repeated Output outputs = 7;
}

message Processor {
    enum Type {
        ROLLUP = 0;
        RATE = 1;
        CONVERT = 2;
    }

    // The type of the processor: rate or convert
    Type type = 1;

    // The target metric name and a path of string e.g. ["traffic", "bytes", direction]
    repeated string target = 2;

    // The processor args
    oneof args {
        ConvertProcessorArgs convert_args = 3;
        RateProcessorArgs rate_args = 4;
        RollupProcessorArgs rollup_args = 5;
    }
}

message ConvertProcessorArgs {
    double factor = 1;
}

message RateProcessorArgs {
    bool allow_negative = 1;
}

message RollupProcessorArgs {

    enum AggregationFunction {
        SUM = 0;
        AVG = 1;
        MAX = 2;
    }

    // The aggregation function, either SUM, AVG or MAX
    AggregationFunction agg = 1;

    // The rollup window, e.g. "5m"
    string period = 2;
}

message Output {
    enum Type {
        TILE = 0;
        CURRENT = 1;
        TAG = 2;
    }

    // The type of the metric: bytes, counter, gauge or string
    Type type = 1;

    // Output args
    oneof args {
        TileOutputArgs tile_args = 2;
        CurrentOutputArgs current_args = 3;
        TagOutputArgs tag_args = 4;
    }
}

message TileOutputArgs {
    // The span of the tile to write into e.g. 30s samples into a span of "1d" (2880 points per tile)
    string span = 1;
}

message CurrentOutputArgs {
}

message TagOutputArgs {
    // The span of the tile to write into e.g. 30s samples into a span of "1d" (2880 points per tile)
    string span = 1;

    // The output metric name for the tag resource e.g. tags/sites/anl::traffic/$suffix
    repeated string metric = 2;
}

//
// Service Request objects
//

message TileRequest {
    // The namespace
    Namespace namespace = 1;

    // The resource as a path
    Resource resource = 2;

    // The metric to get the tile from, for example "traffic/in"
    string metric = 3;

    // The tile index, for example "1d-1234"
    string index = 4;
}

message OrganizationListRequest {
}

message OrganizationRequest {
    string name = 1;
}

message CollectionListRequest {
    // The short name of the Organization containing the Collections
    string organization = 1;
}

message CollectionRequest {
    // The Organization to look up the Collection in
    string organization = 1;

    // The short name of the Collection
    string name = 2;
}

message ResourceGroupListRequest {
    // The namespace containing the Resource Groups
    Namespace namespace = 1;

    // parent root
    repeated string parent = 2;
}

message ResourceGroupRequest {
    // The namespace containing the Resource Group
    Namespace namespace = 1;

    // The name of the Resource Group
    string name = 2;
}

message CreateSourceRequest {
    // The namespace containing the Source
    Namespace namespace = 1;

    // The index of the Source, which should be unique, and is how the source is referred to within ingest events
    int32 index = 2;

    // The relative priority of the Source used to merge events
    int32 priority = 3;

    // A human friendly escription of the Source and what it represents
    string description = 4;
}

message ChangeSourcePriorityRequest {
    // The namespace containing the Source
    Namespace namespace = 1;

    // The index of the Source to update
    int32 index = 2;

    // The new relative priority of the Source
    int32 priority = 3;
}

message SourceListRequest {
    Namespace namespace = 1;
}

message SourceRequest {
    // The Organization and Collection of the source
    Namespace namespace = 1;

    // The index of the Source
    string index = 2;
}

message DeleteSourceRequest {
    // The namespace containing the Source
    Namespace namespace = 1;

    // The index of the Source to delete
    int32 index = 2;
}

message RuleListRequest {
    // The namespace to request the ingest rules within
    Namespace namespace = 1;
}

message RuleRequest {
    // The namespace containing the ingest rule
    Namespace namespace = 1;

    // The id of the rule to fetch
    int32 id = 2;
}

message CreateRuleRequest {

    enum Type {
        BYTES = 0;
        COUNTER = 1;
        GAUGE = 2;
        STRING = 3;
    }

    // The type of the metric to ingest, may be counter, gauge or string
    Type type = 1;

    // The namespace to register the rule within
    Namespace namespace = 2;

    // The scope wildcard which determines which Resources the Metric will apply to.
    // e.g. "devices/*/interfaces/*"
    string scope = 3;

    // The base name of the metric e.g. "traffic"
    string name = 4;

    // Units, applicable to counter and gauge types. For counter types the output rates
    // will be ${units}/s and for gauges the output units will just be ${units}. For example
    // a counter of errors my have units "errors" and will output "errors/sec", while a
    // temperature gauge may have units "deg C" which will be its output units as well
    //
    // If the counter units is "bytes" then the counter is assumed to be a traffic counter
    // and rate outputs will be converted automatically to bits per second (bps).
    //
    string units = 5;

    // The suffix of the metric e.g. "in" and "out"
    string suffix = 6;

    // The tag suffix of the metric e.g. "in" maybe mapped to from both "in_inProfile" and "in_outProfile"
    // to sum those together in the resulting tag metric.
    string tag_suffix = 7;

    // The alignment of the data to periodic boundaries e.g. "30s" or "5m"
    string align = 8;

}

message MatchersRequest {
    // The namespace to request the Matchers within, based on the Rules registered for the
    // Organization and Collection
    Namespace namespace = 1;
}

//
// Netbeam gRPC API Service description
//

service Netbeam {

    //
    // Queries
    //

    // Requests a tile from the netbeam core for a specific metric
    rpc FetchTile (TileRequest) returns (pond.TimeSeries) {}

    //
    // Organizations
    //

    // Request the list of Organizations registered with netbeam
    rpc ListOrganizations (OrganizationListRequest) returns (OrganizationList) {}

    // Get a specific Organization by supplying it's short name
    rpc GetOrganization (OrganizationRequest) returns (Organization) {}

    //
    // Collections
    //

    // Request the list of Collections within an Organization registered with netbeam
    rpc ListCollections (CollectionListRequest) returns (CollectionList) {}

    // Get a specific Collection by supplying the Organization it is in as well as the Collection short name
    rpc GetCollection (CollectionRequest) returns (Collection) {}

    //
    // Resource Groups
    //

    // Request the list of resource groups within a Collection registered with netbeam
    rpc ListResourceGroups (ResourceGroupListRequest) returns (ResourceGroupList) {}

    // Get a specific Resource Group by supplying the Collection it is in as well as the Resource Group short name
    rpc getResourceGroup (ResourceGroupRequest) returns (ResourceGroup) {}

    //
    // Sources
    //

    // Request the list of all Sources within a Collection. The list will be returned in order of priority.
    rpc ListSources (SourceListRequest) returns (SourceList) {
        option (google.api.http) = { get: "/v1/orgs/{namespace.organization}/collections/{namespace.collection}/sources" };
    }

    // Get a specific Source by supplying the Organization, Collection and the Source index
    rpc GetSource (SourceRequest) returns (Source) {
        option (google.api.http) = { get: "/v1/orgs/{namespace.organization}/collections/{namespace.collection}/sources/{index}" };
    }

    // Registers a new Source with the Collection
    rpc CreateSource (CreateSourceRequest) returns (Source) {}

    // Update the Source priority
    rpc UpdateSourcePriority (ChangeSourcePriorityRequest) returns (Source) {}

    // Delete the Source
    rpc DeleteSource (DeleteSourceRequest) returns (Empty) {}

    //
    // Rules
    //

    // Request a list of all ingest rules registered to the Collection
    rpc ListRules (RuleListRequest) returns (RuleList) {}

    // Get a specific rule by supplying the Organization, Collection and rule identifier
    rpc GetRule (RuleRequest) returns (Rule) {}

    // Register a new ingest rule
    rpc CreateRule (CreateRuleRequest) returns (Rule) {}

    //
    // Matchers
    //

    // Given an Organization and Collection, return the Matchers derived from
    // the rules registered within that Collection. Matchers describe the processing graph for
    // resources and metrics that match. Matchers are described using Rules then built into
    // a tree of matchers that describe the transformations and output sinks that should be
    // applied.
    rpc ListMatchers (MatchersRequest) returns (Matchers) {}
}
