syntax = "proto3";

import "pond.proto";

import "google/api/annotations.proto";

package netbeam;

option go_package = "github.com/esnet/proto/netbeam";

message Empty {
}

// The namespace, which is made up of the organization and the collection e.g. { organization: "esnet", collection: "prod"}
message Namespace {
    // The organization this request is associated with e.g. "esnet"
    string organization = 1;

    // The collection within the organization's data the request is for. e.g. "prod"
    string collection = 2;
}

// The full resource path e.g. ["devices", "chic-cr5", "interfaces", "1/1/1"]
message ResourcePath {
    repeated string path = 1;
}

message Organization {
    // The database ID of the organization
    int32 id = 1;

    // The short name of the organization
    string name = 2;

    // A longer more descriptive name for the organization
    string description = 3;
}

message OrganizationList {
    // The list of organizations
    repeated Organization organizations = 1;
}

message Collection {
    // The database ID of the Collection
    int32 id = 1;

    // The namespace of anything within this Collection, contains both the Organization name
    // and the Collection name e.g. {organization: "esnet", collection: "prod"}
    Namespace namespace = 2;

    // A longer more human readable name or description for the Collection
    string description = 3;
}

message CollectionList {
    // A list of Collections
    repeated Collection collections = 1;
}

// e.g: devices, tags, interfaces, etc.
message ResourceGroup {
    // The short name of the resource group
    string name = 1;
}

message ResourceGroupList {
    // A list of ResourceGroups
    repeated ResourceGroup resourceGroups = 1;

    // The namespace of anything within this Collection, contains both the Organization name
    // and the Collection name e.g. {organization: "esnet", collection: "prod"}
    Namespace namespace = 2;

    // The parent path of the resource groups
    string parent = 3;
}

// e.g: star-cr5, intercloud, etc.
message Resource {
    // The name of this resource
    string name = 1;
}

message ResourceList {
    // A list of Resources
    repeated Resource resources = 1;

    // The namespace that contains these resources
    Namespace namespace = 2;

    // The parent path of the resources
    string parent = 3;
}

message Source {
    // The database ID of the Source
    int32 id = 1;

    // The namespace that contains the Source e.g. {organization: "esnet", collection: "prod"}
    Namespace namespace = 2;

    // The index of the Source, which is how the Source is referred to within ingest Events
    int32 index = 3;

     // Priority, which determines which Events will be used if the same Event comes from multiple sources
    int32 priority = 4;

    // Description of the Source and what it represents
    string description = 5;
}

message SourceList {
    // The list of Sources
    repeated Source sources = 1;
}

// An ingest rule that describes at a high level how some particular metric will be processed.
// This consists of three parts: A matcher (based on the namespace of the event and the scope
// that matches the resource), a Type (which corresponds to different netbeam handling of the event),
// and finally parameters which further control the way that metric is processed (alignment of
// the data, naming and units).
message Rule {
    // The ID of the Metric
    int32 id = 1;

    // The namespace to register the rule within
    Namespace namespace = 2;

    enum Type {
        BYTES = 0;
        COUNTER = 1;
        GAUGE = 2;
        STRING = 3;
    }

    // The type of the metric: bytes, counter, gauge or string
    Type type = 3;

    // The scope wildcard which determines which Resources the Metric will apply to
    string scope = 4;

    // The base name of the metric e.g. "traffic"
    string name = 5;

    // The suffic of the metric e.g. "in" or "out"
    string suffix = 6;

    // The suffix for the output tiles if those are generated by the Rule type. For example when
    // writing SAPs, both in_inProfile and in_outProfile are written to the tag suffix "in"
    string tag_suffix = 7;

    // The alignment of the data to periodic boundaries
    string align = 8;

    // The  units of the output data if applicable. Applies to gauges and counters. Counters with units of
    // bytes is assumed to output bits per second rates. This is a special case. String types are unitless.
    // A gauge of say kb of memory will output kb as its units. A counter of units "errors" will output a
    // rate of errors as "errors/sec".
    string units = 9;

}

message RuleList {
    // The list of rules
    repeated Rule rules = 1;
}

//
// Datagraphs
//

message Matchers {
    // A list of matchers within that namespace
    repeated Matcher matchers = 2;
}

message Matcher {
    // The organization and collection of the matcher
    Namespace namespace = 1;

    // The name of the matcher
    string name = 2;

    // The matcher's wildcards against the incoming resource. If any of the wildcards
    // matches against the resources the rule will be active.
    repeated string scope = 3;

    // A human readable description as to what this matcher represents
    string description = 4;

    // Units of the metrics that this matcher applies to
    string units = 5;

    // Alignment of this data, for example "30s" would align this data to every 30 seconds (4:30, 5:00, 5:30 ...)
    string align = 6;

    // A list of processors to run as a result of this match on the incoming metric event. A processor will
    // transform this Event into another Event (with a different metric name) that may match other Matchers.
    repeated Processor processors = 7;

    // A list of Outputs which will write or otherwise emit the data, for example to a specific table.
    repeated Output outputs = 8;
}

message Processor {
    enum Type {
        ROLLUP = 0;
        RATE = 1;
        CONVERT = 2;
    }

    // The type of the processor: rate or convert
    Type type = 1;

    // The target metric name and a path of string e.g. ["traffic", "bytes", direction]
    repeated string target = 2;

    // The processor args
    oneof args {
        ConvertProcessorArgs convert_args = 3;
        RateProcessorArgs rate_args = 4;
        RollupProcessorArgs rollup_args = 5;
    }
}

message ConvertProcessorArgs {
    double factor = 1;
}

message RateProcessorArgs {
    bool allow_negative = 1;
}

message RollupProcessorArgs {

    enum AggregationFunction {
        SUM = 0;
        AVG = 1;
        MAX = 2;
    }

    // The aggregation function, either SUM, AVG or MAX
    AggregationFunction agg = 1;

    // The rollup window, e.g. "5m"
    string period = 2;
}

message Output {
    enum Type {
        TILE = 0;
        CURRENT = 1;
        TAG = 2;
    }

    // The type of the metric: bytes, counter, gauge or string
    Type type = 1;

    // Output args
    oneof args {
        TileOutputArgs tile_args = 2;
        CurrentOutputArgs current_args = 3;
        TagOutputArgs tag_args = 4;
    }
}

message TileOutputArgs {
    // The span of the tile to write into e.g. 30s samples into a span of "1d" (2880 points per tile)
    string span = 1;
}

message CurrentOutputArgs {
}

message TagOutputArgs {
    // The span of the tile to write into e.g. 30s samples into a span of "1d" (2880 points per tile)
    string span = 1;

    // The output metric name for the tag resource e.g. tags/sites/anl::traffic/$suffix
    repeated string metric = 2;
}

//
// Service Request objects
//

message TileRequest {
    // The namespace
    Namespace namespace = 1;

    // The resource as a path
    ResourcePath resource = 2;

    // The metric to get the tile from, for example "traffic/in"
    string metric = 3;

    // The tile index, for example "1d-1234"
    string index = 4;
}

message OrganizationListRequest {
}

message OrganizationRequest {
    string name = 1;
}

message CollectionListRequest {
    // The short name of the Organization containing the Collections
    string organization = 1;
}

message CollectionRequest {
    // The Organization to look up the Collection in
    string organization = 1;

    // The short name of the Collection
    string name = 2;
}

message CreateCollectionRequest {
    // The Organization to look up the Collection in
    string organization = 1;

    // The name of the collection to create
    string name = 2;

    // A longer more human readable name or description for the Collection
    string description = 3;
}

message ResourceGroupListRequest {
    // The namespace containing the Resource Groups
    Namespace namespace = 1;

    // The parent path to the surrounding ResourceGroup
    repeated string parent = 2;

    // An optional index to get the resource groups list at a given month.
    string index = 3;
}

message ResourceListRequest {
    // The namespace containing the resource
    Namespace namespace = 1;

    // The parent path to the surrounding ResourceGroup
    repeated string parent = 2;
}

message CreateSourceRequest {
    // The namespace containing the Source
    Namespace namespace = 1;

    // The index of the Source, which should be unique, and is how the source is referred to within ingest events
    int32 index = 2;

    // The relative priority of the Source used to merge events
    int32 priority = 3;

    // A human friendly description of the Source and what it represents
    string description = 4;
}

message ChangeSourcePriorityRequest {
    // The namespace containing the Source
    Namespace namespace = 1;

    // The index of the Source to update
    int32 index = 2;

    // The new relative priority of the Source
    int32 priority = 3;
}

message SourceListRequest {
    Namespace namespace = 1;
}

message SourceRequest {
    // The Organization and Collection of the source
    Namespace namespace = 1;

    // The index of the Source
    string index = 2;
}

message DeleteSourceRequest {
    // The namespace containing the Source
    Namespace namespace = 1;

    // The index of the Source to delete
    int32 index = 2;
}

message RuleListRequest {
    // The namespace to request the ingest rules within
    Namespace namespace = 1;
}

message AllRuleListRequest {
}

message RuleRequest {
    // The namespace containing the ingest rule
    Namespace namespace = 1;

    // The id of the rule to fetch
    int32 id = 2;
}

message CreateRuleRequest {

    enum Type {
        BYTES = 0;
        COUNTER = 1;
        GAUGE = 2;
        STRING = 3;
    }

    // The type of the metric to ingest, may be counter, gauge or string
    Type type = 1;

    // The namespace to register the rule within
    Namespace namespace = 2;

    // The scope wildcard which determines which Resources the Metric will apply to.
    // e.g. "devices/*/interfaces/*"
    string scope = 3;

    // The base name of the metric e.g. "traffic"
    string name = 4;

    // Units, applicable to counter and gauge types. For counter types the output rates
    // will be ${units}/s and for gauges the output units will just be ${units}. For example
    // a counter of errors my have units "errors" and will output "errors/sec", while a
    // temperature gauge may have units "deg C" which will be its output units as well
    //
    // If the counter units is "bytes" then the counter is assumed to be a traffic counter
    // and rate outputs will be converted automatically to bits per second (bps).
    //
    string units = 5;

    // The suffix of the metric e.g. "in" and "out"
    string suffix = 6;

    // The tag suffix of the metric e.g. "in" maybe mapped to from both "in_inProfile" and "in_outProfile"
    // to sum those together in the resulting tag metric.
    string tag_suffix = 7;

    // The alignment of the data to periodic boundaries e.g. "30s" or "5m"
    string align = 8;

}

message MatchersRequest {
}

//
// Netbeam gRPC API Service description
//

service Netbeam {

    //
    // Queries
    //

    // Requests a tile from the netbeam core for a specific metric. Currently does
    // not a have a REST counterpart.
    rpc FetchTile (TileRequest) returns (pond.TimeSeries) {}

    //
    // Resource traversal
    //

    // Request the list of resource groups within a Collection registered with netbeam
    rpc ListResourceGroups (ResourceGroupListRequest) returns (ResourceGroupList) {
        option (google.api.http) = { get: "/v1/resources/groups" };
    }


    // Request the list of resources within a resource group
    rpc ListResources (ResourceListRequest) returns (ResourceList) {
        option (google.api.http) = { get: "/v1/resources" };

    }


    //
    // Organizations
    //

    // Request the list of Organizations registered with netbeam.
    // You need to have special permissions to access this list.
    rpc ListOrganizations (OrganizationListRequest) returns (OrganizationList) {
        option (google.api.http) = { get: "/v1/orgs" };
    }

    // Get a specific Organization by supplying its short name. Currently this will just
    // return the internal id, the name, and a description associated with the organization
    rpc GetOrganization (OrganizationRequest) returns (Organization) {
        option (google.api.http) = { get: "/v1/orgs/{name}" };
    }

    //
    // Collections
    //

    // Request the list of registered Collections for an Organization.
    rpc ListCollections (CollectionListRequest) returns (CollectionList) {
        option (google.api.http) = { get: "/v1/orgs/{organization}/collections" };
    }

    // Get a specific Collection by supplying the `organization` it is in as well
    // as the Collection short `name`.
    rpc GetCollection (CollectionRequest) returns (Collection) {
        option (google.api.http) = { get: "/v1/orgs/{organization}/collections/{name}" };
    }

    // Creates a new Collection registered to the Organization. A collection is
    // created with the `organization`, `name` and `description`.
    rpc CreateCollection (CreateCollectionRequest) returns (Collection) {
        option (google.api.http) = {
            post: "/v1/orgs/{organization}/create_collection",
            body: "*"
        };
    }

    //
    // Sources
    //

    // Request the list of all Sources within a Collection by supplying the `namespace` of the
    // Collection. The list will be returned in order of priority that events with that source
    // will be merged together. 
    rpc ListSources (SourceListRequest) returns (SourceList) {
        option (google.api.http) = {
            get: "/v1/orgs/{namespace.organization}/collections/{namespace.collection}/sources"
        };
    }

    // Get a specific Source by supplying the `namespace` (`organization` and `collection`)
    // and the Source's identifying `index`.
    rpc GetSource (SourceRequest) returns (Source) {
        option (google.api.http) = {
            get: "/v1/orgs/{namespace.organization}/collections/{namespace.collection}/sources/{index}"
        };
    }

    // Registers a new Source with the Collection. A source is what is associated with an event
    // sent to netbeam. Sources tell netbeam where the event came from. Each source has a priority
    // relative to other sources, so that as events are ingested multiple redundent sources can
    // be reconciled with each other. Lower `priority` sources win. Each source also has an `index`,
    // while is how the source is referenced in an event, along with a `description` which should
    // be a short human readable string describing the source to identify it in the future.
    rpc CreateSource (CreateSourceRequest) returns (Source) {
        option (google.api.http) = { 
            post: "/v1/orgs/{namespace.organization}/collections/{namespace.collection}/create_source"
            body: "*"
        };
    }

    // Update the Source's priority
    rpc UpdateSourcePriority (ChangeSourcePriorityRequest) returns (Source) {
        option (google.api.http) = { 
            post: "/v1/orgs/{namespace.organization}/collections/{namespace.collection}/change_source_priority"
            body: "*"
        };
    }

    // Delete the Source
    rpc DeleteSource (DeleteSourceRequest) returns (Empty) {
        option (google.api.http) = { 
            post: "/v1/orgs/{namespace.organization}/collections/{namespace.collection}/delete_source"
            body: "*"
        };
    }

    //
    // Rules
    //

    // Request a list of all ingest rules registered to a specific Collection
    rpc ListRules (RuleListRequest) returns (RuleList) {
        option (google.api.http) = {
            get: "/v1/orgs/{namespace.organization}/collections/{namespace.collection}/rules"
        };
    }

    // Request a list of all ingest rules regardless of Collection. This is used internally for
    // netbeam operations and so requires special permissions as it returns rules from all
    // organizations.
    rpc ListAllRules (AllRuleListRequest) returns (RuleList) {
        option (google.api.http) = {
            get: "/v1/rules"
        };
    }

    // Get a specific rule by supplying the Organization, Collection and rule identifier
    rpc GetRule (RuleRequest) returns (Rule) {
        option (google.api.http) = {
            get: "/v1/orgs/{namespace.organization}/collections/{namespace.collection}/rules/{id}"
        };
    }

    // Register a new ingest rule.
    //
    // Currently a rule can be of 4 `type`s:
    //  * BYTES - Byte counters, such as network traffic
    //  * COUNTER - A pure counter, such as errors or incidents
    //  * GAUGE - A general numeric value, such as temperature
    //  * STRING - A general string value, such as meta data like the ifName of an interface
    //
    // Rules are matched to events using both a wildcard matcher to the resource defined by
    // the `scope` and the metric base `name` (e.g. `traffic`) combined with the a `suffix`
    // such as the direction of the traffic (e.g. `in` or `out`).
    //
    // Once matched, the `type` determines what the processing of that event looks like.
    // Currently a `BYTES` type will be aligned, converted to rates, converted to bits/sec
    // and the written out to the timeseries. `COUNTER` is similar, it will be aligned and
    // converted to a rate (count/sec), then written to the timeseries. `GAUGE` types will
    // be aligned only, then written out. `STRING` types will just be written to the latest
    // value table.
    //
    // Options used in the above processing include the `align` value, such as "30s".
    //
    // The `tag_suffix` of the metric allows different suffixes to map to the same suffix
    // in a tag output. The main usecase for this is to map "in_inProfile" and "in_outProfile"
    // in a SAP (for example), to "in" as the tag suffix (e.g. oscars/in).
    //
    // The `units` is currently not surfaced outside of netbeam, but maybe in the future.
    // It should be the units of the output (for example: "bps") not the input ("bytes").
    //
    // Creating a new rule needs to be done via a gRPC call (or with the cli).
    //
    rpc CreateRule (CreateRuleRequest) returns (Rule) {}

    //
    // Matchers
    //

    // Return the Matchers derived from the collection of all rules. This call is
    // used internally as part of netbeam processing operations. To control processing
    // of events create Rules for those events using this API.
    //
    // Matchers describe the processing graph for resources and metrics that match.
    // Matchers are described using Rules then built into a tree of matchers that
    // describe the transformations and output sinks that should be applied.
    rpc ListMatchers (MatchersRequest) returns (Matchers) {
        option (google.api.http) = {
            get: "/v1/matchers"
        };
    }
}
